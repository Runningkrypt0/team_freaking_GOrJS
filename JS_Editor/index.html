<html>
	<head>
		<title>Artificial Amateur</title>
		<style>
			@font-face {
				font-family: 'inconsolata';
				src: url('fonts/inconsolata.woff') format('woff');
				font-weight: normal;
				font-style: normal;
			}
			
			body {
				margin:0;
				font-family: 'inconsolata';
				font-size: 15px;
				line-height: 18px;
				overflow: hidden;
			}
			
			canvas {width: 100%; height: 100%; }
			container {width:100%; height: 100% }
		</style>
	</head>
	<body>
		<input id="file_selector" type="file" style="visibility:hidden;max-height:0;" onchange='readText(this)'/>
		<div id="container">
			
			<script src = "js/three.min.js"></script>
			<script src = "js/dat.gui.js"></script>
			<script src = "js/Shapes.js"></script>
			<script src = "js/OrbitControls.js"></script>
			<script src = "js/csg.js"></script>
			<script src = "js/ThreeCSG.js"></script>
			<script src = "js/jquery.js"></script>
			<script>
			
				var grabbingSpace = false;
				var _LIMIT_ = 9999999
				var _STOP_ = -1;
				
				
				
				function updateGeometry(){
					objects[0].generate_object();
					var me = new ThreeBSP(objects[0].object.geometry);
					for(p = 1; p < objects.length;p++){
						objects[p].generate_object();
						//if(objects[p].sign){
							me = me.union(new ThreeBSP(objects[p].object.geometry));
						//}
					}
					//for(n = 0; n < objects.length;n++){
					//	if(!(objects[n].sign)){
					//		me = me.subtract(new ThreeBSP(objects[n].object.geometry));
					//	}
					//}
					
					area.geometry = me.toGeometry();
				}
				
				
				
				var textFile = null;
				makeTextFile = function (text) {
					var data = new Blob([text], {type: 'text/plain'});

					// If we are replacing a previously generated file we need to
					// manually revoke the object URL to avoid memory leaks.
					if (textFile !== null) {
					  window.URL.revokeObjectURL(textFile);
					}

					textFile = window.URL.createObjectURL(data);

					window.open(textFile,'_blank');
				};
				
				var reader;
				function checkFileAPI() {
					if (window.File && window.FileReader && window.FileList && window.Blob) {
						reader = new FileReader();
						return true; 
					} else {
						alert('The File APIs are not fully supported by your browser. Fallback required.');
						return false;
					}
				}
				checkFileAPI();
				function readText(filePath) {
					var output = ""; //placeholder for text output
					console.log("opening")
					if(filePath.files && filePath.files[0]) {           
						reader.onload = function (e) {
							output = e.target.result;
							loadFromText(output);
						};//end onload()
						reader.readAsText(filePath.files[0]);
					}//end if html5 filelist support
					else if(ActiveXObject && filePath) { //fallback to IE 6-8 support via ActiveX
						try {
							reader = new ActiveXObject("Scripting.FileSystemObject");
							var file = reader.OpenTextFile(filePath, 1); //ActiveX File Object
							output = file.ReadAll(); //text contents of file
							file.Close(); //close file "input stream"
							loadFromText(output);
						} catch (e) {
							if (e.number == -2146827859) {
								alert('Unable to access local files due to browser security settings. ' + 
								 'To overcome this, go to Tools->Internet Options->Security->Custom Level. ' + 
								 'Find the setting for "Initialize and script ActiveX controls not marked as safe" and change it to "Enable" or "Prompt"'); 
							}
						}       
					}
					else { //this is where you could fallback to Java Applet, Flash or similar
						return false;
					}
					return true;
				};
				function gatherThouhts(text,focus){
					var thought = "";
					while(focus<text.length&&text[focus]!=","){
						thought+=text[focus++];
					}
					focus++;
					return [thought,focus];
				}
				function loadFromText(text){
					objects=[];
					var state = 0;
					var focus = 0;
					var geometry = undefined;
					while(focus<text.length){
						var tuple = gatherThouhts(text,focus);
						thought = tuple[0];
						focus = tuple[1];
						if(thought=="O"){
							if(geometry!==undefined){
								geometry.vertices.push(geometry.vertices[0].clone());
								objects.push(new room_Part());
								objects[objects.length-1].border = new THREE.Line(geometry);
							}
							geometry = new THREE.Geometry();
							state = 1;
						}
						else if(state==1){
							var tuple = gatherThouhts(text,focus);
							var B = tuple[0];
							focus = tuple[1];
							var tuple = gatherThouhts(text,focus);
							var C = tuple[0];
							focus = tuple[1];
							geometry.vertices.push(new THREE.Vector3(parseInt(thought),parseInt(B),parseInt(C)));
						}
					}
					if(geometry!==undefined){
						geometry.vertices.push(geometry.vertices[0].clone());
						objects.push(new room_Part());
						objects[objects.length-1].border = new THREE.Line(geometry);
					}
					
					roster.displayEdit();
				}
				
				var walls = [];
				
				var area = new Room();
			
				var camera, controls, scene, renderer;
				
				//var negative = [];
				var objects = [];
				
				
				
				var roster = {
					RESET_MODE : function(){
					
					},
					
					SET_MODE_BORDER_EDIT : function(){
						roster.RESET_MODE();
						
					},
					
					_WIREFRAME_ : false,
					index: 0,
					displaySurface : function(){
						updateGeometry();
						walls = area.drawSurfaces();
						collisionObjects=[];
						
						if(scene){
							reality = scene.clone();
							for(i=0; i<walls.length;i++){
								reality.add( walls[i] );
							}
						}
					},
					save : function(){
						//save parts as flattened csv vertex lists
						var total = "";
						for(var i = 0; i < objects.length;i++){
							total += "O"
							for(var j = 0; j < objects[i].border.geometry.vertices.length-1;j++){
								total += ","+objects[i].border.geometry.vertices[j].x;
								total += ","+objects[i].border.geometry.vertices[j].y;
								total += ","+objects[i].border.geometry.vertices[j].z;
							}
						}
						makeTextFile(total);
					},
					load : function(){
						$('#file_selector').click();
					},
					
					
					displayWalls : function(){
						updateGeometry();
						walls = area.drawWalls();
						collisionObjects=[];
						
						if(scene){
							reality = scene.clone();
							for(i=0; i<walls.length;i++){
								reality.add( walls[i] );
							}
						}
					},
					displayEdit : function(){
						collisionObjects = [];
						for(i=0;i<objects.length;i++){
							collisionObjects.push(objects[i].border);
						}
						
						if(!scene){
							for(i = 0; i < objects.length;i++){
								objects[i].object.material.transparent = true;
							}
							return;
						}
						
						reality = scene.clone();
						for(i = 0; i < objects.length;i++){
							reality.add(objects[i].border);
						}
					},
					displayTest : function(){
						collisionObjects = [];
						
						//reality = scene.clone();
						for(i = 0; i < objects.length;i++){
							objects[i].generate_object();
							reality.add(objects[i].object);
						}
					},
					addPart: function() {
						var newobject = new room_Part();
						objects.push(newobject);
						roster.displayEdit();
					},
					removePart: function(){
						objects.splice(this.index,1);
						roster.displayEdit();
					}
					
					
				}
				var newobject = new room_Part();
				objects.push(newobject);
				
				
				var gui = new dat.GUI();
				gui.add(roster, "save").name("Save");
				gui.add(roster, "load").name("Load");
				var roomFolder = gui.addFolder("Edit Rooms");
				roomFolder.add(roster, "addPart").name("Add Room");
				roomFolder.add(roster, "displayEdit").name("Edit Room Layout");
				roomFolder.add(roster, "displayTest").name("Display Inset Borders");
				roomFolder.add(roster, "displaySurface").name("Display Preview");
				//var renderFolder = gui.addFolder("Display Options");
				//renderFolder.add(roster, "_WIREFRAME_").name("Wire Frame Mode");
				//renderFolder.add(roster, "displayEdit").name("Edit:");
				//renderFolder.add(roster, "displaySurface").name("Preview:");
				//renderFolder.add(roster, "displayWalls").name("Render:");
								
				var selected = new Selector();
				var selectedPoint = 0;
				
				roster.chosen = gui.add(roster, "index").step(1).listen().onFinishChange(function(value){selected.update(objects[value])});
				
				//var cubeb = new THREE.CubeGeometry(40, 160, 40);
				//negative.push(cubeb);
				
				var Grid = new THREE.Mesh(new THREE.PlaneGeometry( 10000, 10000),new THREE.MeshBasicMaterial({color: 0xffff00,side: THREE.DoubleSide}));
				Grid.geometry.rotateX(-Math.PI*0.5);
				
				

				//var sphere = new THREE.SphereGeometry(100, 32, 32);
				//var sphere_bsp = new ThreeBSP( sphere, {offset: {x: 1, y:2, z: 1}} );

				//console.time('operation');
				//var union = cube_bsp.subtract( sphere_bsp );
				//console.timeEnd('operation');

				//console.time('mesh');
				//var polygon = new THREE.Mesh( union.toGeometry(), new THREE.MeshNormalMaterial );
				//console.timeEnd('mesh');
				
				//polygon.geometry.computeFaceNormals(); // highly recommended...
				
				var collisionObjects = [];
				
				var raycaster;
				var mouse;
				
				
				init();
				animate();
				
				//to write TONIGHT
				// hollow
				// connection addition for plane meshes 
				// box3 extension for connections   (checkish)
				
				//to write
				// subtract: inputs: 2 box3's, subtracts b from a and returns array of box3's

				function init() {
					scene = new THREE.Scene();
					scene.fog = new THREE.FogExp2( 0x111111, 0.00002 );

					renderer = new THREE.WebGLRenderer();
					renderer.setClearColor( scene.fog.color );
					renderer.setPixelRatio( window.devicePixelRatio );
					renderer.setSize( window.innerWidth, window.innerHeight );

					var container = document.getElementById( 'container' );
					container.appendChild( renderer.domElement );

					camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
					camera.position.z = 500;
					camera.position.y = 150;
					camera.position.x = 150;

					controls = new THREE.OrbitControls( camera, renderer.domElement );
					//controls.addEventListener( 'change', render ); // add this only if there is no animation loop (requestAnimationFrame)
					controls.enableDamping = true;
					controls.dampingFactor = 0.25;
					controls.enableZoom = true;
					controls.enableKeys = false;
					

					
					// world-------------------------------------------------------------------------------------------------
					
					//for(i=0; i<walls.length;i++){
					//	scene.add( walls[i] );
					//}

					
					
					// 0-----------------------------------------------------------------------------------------------------
					// lights

					light = new THREE.DirectionalLight( 0xffffff );
					light.position.set( 1, 1, 1 );
					scene.add( light );

					light = new THREE.DirectionalLight( 0x002288 );
					light.position.set( -1, -1, -1 );
					scene.add( light );

					light = new THREE.AmbientLight( 0x222222 );
					scene.add( light );

					//

					window.addEventListener( 'resize', onWindowResize, false );
					
					//select object
					raycaster = new THREE.Raycaster();
					raycaster.linePrecision = 20;
					mouse = new THREE.Vector2();
					
					//document.addEventListener( 'touchstart', onDocumentTouchStart, false );
					
					//scene.add(Grid);
					
					reality = scene.clone();
					roster.displayEdit();
				}

				function onWindowResize() {

					camera.aspect = window.innerWidth / window.innerHeight;
					camera.updateProjectionMatrix();

					renderer.setSize( window.innerWidth, window.innerHeight );

				}

				function animate() {

					requestAnimationFrame( animate );

					controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true

					render();

				}

				function render() {
				
					renderer.render( reality, camera );

				}
			</script>
		</div>
	</body>
</html>